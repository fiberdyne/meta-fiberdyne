diff --git a/sound/soc/sh/rcar/ssi.c b/sound/soc/sh/rcar/ssi.c
index 3265116..ef7969b 100644
--- a/sound/soc/sh/rcar/ssi.c	
+++ b/sound/soc/sh/rcar/ssi.c	
@@ -15,7 +15,7 @@
 #include <linux/delay.h>
 #include "rsnd.h"
 #define RSND_SSI_NAME_SIZE 16
-
+#define DINFO(fmt, ...) printk(KERN_ERR  fmt,  ##__VA_ARGS__)
 /*
  * SSICR
  */
@@ -67,6 +67,12 @@
 
 #define SSI_NAME "ssi"
 
+// Hack in ADSP support for Master clock configuration
+// ADG registers are inaccessible from the ADSP in curretn system.
+// Hacking this in for now so that this module sets up everything
+// EXCEPT enabling the SSIU/SSI and starting DMA.
+#define DIRTY_HACK_ADSP_TDM
+
 struct rsnd_ssi {
 	struct rsnd_ssi_platform_info *info; /* rcar_snd.h */
 	struct rsnd_ssi *parent;
@@ -116,6 +122,7 @@ int rsnd_ssi_channels(struct rsnd_ssi *ssi)
 	return 2;
 }
 
+
 static int rsnd_ssi_use_busif(struct rsnd_mod *mod)
 {
 	struct rsnd_ssi *ssi = rsnd_mod_to_ssi(mod);
@@ -153,6 +160,7 @@ static void rsnd_ssi_status_check(struct rsnd_mod *mod,
 static int rsnd_ssi_master_clk_start(struct rsnd_ssi *ssi,
 				     struct rsnd_dai_stream *io)
 {
+	DINFO("rsnd_ssi_master_clk_start");
 	struct rsnd_priv *priv = rsnd_mod_to_priv(&ssi->mod);
 	struct snd_pcm_runtime *runtime = rsnd_io_to_runtime(io);
 	struct device *dev = rsnd_priv_to_dev(priv);
@@ -219,6 +227,8 @@ static void rsnd_ssi_master_clk_stop(struct rsnd_ssi *ssi)
 	rsnd_adg_ssi_clk_stop(&ssi->mod);
 }
 
+
+
 static void rsnd_ssi_hw_start(struct rsnd_ssi *ssi,
 			      struct rsnd_dai *rdai,
 			      struct rsnd_dai_stream *io)
@@ -226,7 +236,7 @@ static void rsnd_ssi_hw_start(struct rsnd_ssi *ssi,
 	struct rsnd_priv *priv = rsnd_mod_to_priv(&ssi->mod);
 	struct device *dev = rsnd_priv_to_dev(priv);
 	u32 cr;
-
+    DINFO("rsnd_ssi_hw_start\n");
 	if (0 == ssi->usrcnt) {
 		rsnd_mod_hw_start(&ssi->mod);
 
@@ -254,10 +264,13 @@ static void rsnd_ssi_hw_start(struct rsnd_ssi *ssi,
 		}
 	}
 
-	cr  =	ssi->cr_own	|
-		ssi->cr_clk	|
-		ssi->cr_etc	|
-		EN;
+	cr  =	ssi->cr_own
+		| ssi->cr_clk
+		| ssi->cr_etc
+#ifndef DIRTY_HACK_ADSP_TDM
+		| EN  // Don't enable the SSI for ADSP
+#endif
+		;
 
 	/* clear error status */
 	rsnd_mod_write(&ssi->mod, SSISR, 0);
@@ -323,7 +336,7 @@ void rsnd_ssi_access_enable(struct rsnd_mod *mod, struct rsnd_dai *rdai)
 {
 	struct rsnd_ssi *ssi = rsnd_mod_to_ssi(mod);
 	struct rsnd_dai_stream *io = rsnd_mod_to_io(mod);
-
+  DINFO("rsnd_ssi_access_enable\n");
 	rsnd_ssi_hw_start(ssi, rdai, io);
 
 	return;
@@ -472,7 +485,7 @@ static int rsnd_ssi_init_irq(struct rsnd_mod *mod,
 	struct rsnd_dai_stream *io = rsnd_mod_to_io(mod);
 	struct snd_pcm_runtime *runtime = rsnd_io_to_runtime(io);
 	u32 cr;
-
+  DINFO("rsnd_ssi_init_irq\n");
 	cr = rsnd_ssi_get_cr(ssi, rdai, runtime);
 
 	if (rsnd_dai_is_play(rdai, io))
@@ -595,7 +608,7 @@ static int rsnd_ssi_pio_start(struct rsnd_mod *mod,
 {
 	struct rsnd_ssi *ssi = rsnd_mod_to_ssi(mod);
 	struct rsnd_dai_stream *io = rsnd_mod_to_io(mod);
-
+  DINFO("rsnd_ssi_pio_start\n");
 	/* enable PIO IRQ */
 	ssi->cr_etc = UIEN | OIEN | DIEN;
 
@@ -733,7 +746,7 @@ static int rsnd_ssi_dma_start(struct rsnd_mod *mod,
 	struct rsnd_dma *dma = rsnd_mod_to_dma(&ssi->mod);
 	struct rsnd_dai_stream *io = rsnd_mod_to_io(mod);
 	u32 wsr = 0;
-
+  DINFO("rsnd_ssi_dma_start");
 	/* enable DMA transfer */
 	ssi->cr_etc = DMEN;
 
@@ -750,14 +763,25 @@ static int rsnd_ssi_dma_start(struct rsnd_mod *mod,
 
 	rsnd_mod_write(&ssi->mod, SSIWSR, wsr);
 
+
+#ifndef DIRTY_HACK_ADSP_TDM
 	rsnd_dma_start(dma);
+#else
+	DINFO("not calling rsnd_dma_start..");
+#endif
 
 	rsnd_ssi_hw_start(ssi, ssi->rdai, io);
 
+
+#ifndef DIRTY_HACK_ADSP_TDM
 	rsnd_src_ssiu_start(mod, rdai, rsnd_ssi_use_busif(mod));
+#else
+  DINFO("Not calling rsnd_src_ssiu_start..");
+#endif
 
+#ifndef DIRTY_HACK_ADSP_TDM
 	rsnd_src_enable_dma_ssi_irq(mod, rdai, rsnd_ssi_use_busif(mod));
-
+#endif
 	return 0;
 }
 
